## React 19 Upcoming Features ðŸ§ª

### 1. **React Compiler: Automatic Memoization**

- **Problem**: Manual memoization (using `useMemo`, `useCallback`, etc.) can be cumbersome and error-prone.
- **Solution**: The **React Compiler** now handles memoization optimizations automatically.
- **Benefits**:
  - Cleaner code: Say goodbye to boilerplate memoization.
  - Faster performance: Optimized rendering without manual intervention.
- **Deprecated APIs**:
  - `useMemo`
  - `useCallback`
  - `React.memo`
  - `React.forwardRef`
  - `React.lazy`

---

### 2. **Actions: Stable Server Actions**

- **What's New?**:

  - **Server actions** are now stable.
  - Perform actions on either the server or the client.
  - New hooks for handling server actions.
  - Server action is a convenient way to mutate data without having to create an API endpoint.

- **Example**:

  ```tsx
  "use server";

  const addTodo = async (formData) => {
    const title = formData.get("title");

    await prisma.todo.create({
      data: {
        title,
      },
    });
  };

  <form action={addTodo}>
    <input name="title" />
    <button type="submit">Add Todo</button>
  </form>;
  ```

---

### 3. **New Hooks and Directives**

- **useFormStatus**: Access the status of an action.
- **useFormState**: Handle the result of an action.
- **useOptimistic**: Update the UI optimistically.
- **use client** + **use server directives**: Create client-only or server-only components.

---

### 4. **Suspense: Empowering Loading Lifecycle**

- **Integration**: Suspense now works seamlessly with loading resources (stylesheets, fonts, scripts).
- **Empowered API**: Enhanced capabilities for managing asynchronous data fetching.
- **Example**:
  ```tsx
  <Suspense fallback={<LoadingSpinner />}>
    <LazyComponent />
  </Suspense>
  ```

---

### 5. **SEO Support: Simplified Metadata Handling**

- **Built-in Support**: Render `<title>`, `<meta>`, and `<link>` tags effortlessly.
- **Anywhere in Components**: Drop them in any component, and they'll be placed correctly in the `<head>` tag.

---

### 6. **Replacements Summary**

- **Old Way**:
  - `useMemo`, `useCallback`, `memo` â†’ **React Compiler**
  - `forwardRef` â†’ `ref` is a prop
  - `React.lazy` â†’ **RSC**, promise-as-child
  - `useContext` â†’ `use(Context)`
  - Throwing promises â†’ `use(promise)`

---

### 7. **Server Components Benefits**

- **Faster page loading times âš¡**: They never re-render, resulting in faster page loading times. Unlike in rendering techniques like SSR and SSG, the HTML generated by RSCs is not hydrated on the server and no JS is shipped to the client. This significantly increases page load time and reduces the total JavaScript bundle size.
- **Improved performance**: RSCs offload intensive tasks to the server, reducing the workload on the client. This helps create predictable webpages and improve Core Web Vitals like Largest Contentful Paint (LCP) and First Input Delay (FID).
- **Performant SEO**: Because RSCs generate HTML on the server side, search engines can easily index the content and rank the pages correctly.
- **Enhanced security**: Sensitive data like auth tokens or API keys used in RSCs are executed on the server and never exposed to the browser, preventing unintentional leaks.
- **Data fetching**: Your data source being collocated with Server Components makes data fetching faster, creating more responsive web experiences.

---

### 8. **Server Actions Benefits**

- **Simplified Data Handling**: Server actions simplify data handling. You can mutate data without creating an API endpoint, making your code cleaner and more maintainable.
- **Optimistic UI**: With server actions, you can update the UI optimistically. This means that the UI updates instantly, and the server response is applied later. You can leverage useful hooks like `useOptimistic`, and `useFormStatus` to handle optimistic updates.
- **Less JavaScript**: Server actions reduce the amount of JavaScript shipped to the client. This results in faster page loads and better performance.

---

### 9. **Suspense Benefits**

- **Easy Code Splitting**: Suspense makes code splitting a breeze. You can now split your components and load them only when needed.
- **Data Fetching Made Easy**: With Suspense, you can easily manage asynchronous data fetching. It allows you to suspend rendering until the data is ready, making your components more responsive.
- **Skeleton Loading**: Create a skeleton flow for your async components with ease. Instead of creating a loading spinner, Suspense allows you to render a fallback component until your component is ready to show.
